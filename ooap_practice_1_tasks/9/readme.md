# Отчет

## Работы с фреймворком

В качестве верхнеуровневой схемы работы можно использовать следующую схему:

* инициализируется pygame (выставляется размер окна, fps, и т д)
* далее идет цикл с игрой в котором отрисовываются сцены
* так же обарабываются события и при определенном событии сцена меняется
* отрисовка идет с учитыванием fps

## Работа сцены

Сцена - объект отвечающий за прорисовку и наполнение пользовательского интерфейса. Предполагается использовать сцены 2 типов

* статические - только UI и доп информация + кнопки для смены сцены
* динамический - сама игра

## Сцена с игрой

* инийиализация: в качесте инициализации создается игрок
* в game loop-e используем UnitFactory для генерации врагов с заданной частотой
* Все юниты попадают в класс Observer который отвечает за столкновение юнитов и обрабатывает их вызывая определенную функцию (меняем состояние у юнита если он столкнулся с определенным юнитом)
* Удаляем всех юнитов у которых состояние мертв
* отрисовываем всех юнитов

## Работа с персонажем

* инициализация: для мобов будет специальный класс Factory который и проводит их инициализацию, рассмотрим ее ниже
* изначально задается UnitView - то как выглядит персонаж
* использую UnitView инициализируем UnitState
* Используя UnitState и функцию оперделения местоположения инициализируем Unit
* P.S. в Observer не предполагается добавлять классы бнитов в RunTime - обработка коллизий разных типов персонажей подготавливается заранее

## Тесты для типовых сценариев

* при тестировании функции вычисления местоположения по target новое местоположение должно уменьшить расстояние между таргетом и текущим юнитом
* персонаж изначально имеет состояние Alive
* если монстр догнал персонажа, то при обработке коллизий персонаж должен поменять состояние на Died
* если прошло n секунд и персонаж жив, то пользователь получил 2*n очков
