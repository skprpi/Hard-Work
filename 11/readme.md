# Отчет

## 2.1

* большой класс - встречается если не выделено несколько отдельныйх сущностей и класс начинает делать все и сразу. Например есть класс Player - данный класс реализует и логику перемещения и отрисовку, но что делать когда захотим добавить скины :) Нужно разделить на 3 сущности -> Unit, Controller, Drawer

* много инстансов - это так же может быть причиной god object-a например есть класс который логгирует и делает нотификацию пользователей при некоторых событиях - этот класс будет использоваться в 3 случаях: нужен логгер, нужна нотификация, нужен и логгер и нотификация -> нужно разделить на отдельные классы и уменьшим число использований

## 2.2

* сущность мала/мало делает - происходит в случае черезмерной декомпозиции. Например у нас клиент для работы с MongoDB и мы создаем 2 класса - MongoConnection (отвечает за соединение с базой) и MongoReposutory - реализует некоторые запросы к Mongo. Нет никакого смысла давать пользователю эти 2 сущности т к класс соединения может быть только одного типа, мы только усложняем отправку запросов

## 2.3 

* Метод подходит другому классу - несколько раз встречаел подобное в С++ вместо использования std::visit (ad-hoc) делали обычный полиморфизм. Например в классе файлов делали проверки связанные с настройками окружения :) Логично было бы вынести эту проверку в то самое окружение и не передавать кучу параметров которые уже есть в том самом окружении

## 2.4

* В классе в разных местах загоняются данные - пожалуй самый ужастный (по крайне мере для меня) случай. Очень часто встречается когда объект может иметь/не иметь поля и вместо ad-hoc используется  std::optional и в разных местах в разных случаях происходит инициализация - лечится в идеале классами валидаторами-фабриками - которые создают только валидные объекты с полностью заполненными полями

## 2.5

* Сущность зависит от реализации других сущностей - встречается если есть класс-конфигурации с std::optional и например есть поле std::optional logger - теперь в классе handler мы вынуждены взять или логгер класса-конфигурации (т к у него есть преднастройки) или взять логгер из глобального пространства имен - дефолный логгер. Лечится иерархией логгеров и высталением дефолтного значения по умолчанию

## 2.6

* Down cast - при неправильной работе с родительским и дочерним классом. Например вмето динамического полиморфизма используется статический и нужен явный даункаст

## 2.7

* Создание класса-наследника провоцирует так же создание наследников и в других классах - так же может быть причиной работы со статическим полиморфизмом вмето динамического

## 2.8

* Дочерние классы не используют методы и данные родителя - может проявляется при неправильном проектировании типов. Тут могут помочь миксины (но не всегда)
* Дочерние классы переопределяют родителя - неверная иерархия в наследовании - например если наследуемся от класса без ограничений к классу с ограничениями

## 3.1

* Одно изменение провоцирует изменение в нескольких классов - разделение логики. Был класс который не соответствовал SRP -> он был разделен на 2, которые соответствуют SRP.

## 3.2

* Использование более простого дизайн вместо сложного паттерна - например в С++ есть std::visit - который подразумевает уже под собой логику паттерна visitor. Ориентируясь на стандарт мы можем сразу добавить в нужные классы разную обработку конкретных типов вместо реализации множества различных классов
