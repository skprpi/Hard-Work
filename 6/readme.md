# Отчет

## Задача 1

### Оригиналы

### После изменения

### Как вносились изменения

* Изначально добавился тест `test_boom_sell_creation` который проверять работу подкласса `BoomCell`. Для минимизации изменений
изначально проверяем, что есть возможности добавлять клетку указанного типа и добовляем класс минимально соответствующий данным требованиям

```
# test1.py

def test_btest_boom_sell_creationoom_sell():
    f = Field(5)
    f.set_random_pos_state(BoomCell(), 1)
    assert f.get_state_count(BoomCell) == 1
```

* Чтобы в будующем проверить специфическую часть логики в начале нужно научить конструировать правильное поле с данным состоянием.
Хорошо, что я сделал достаточно гибким интерфейс и это можно делать на лету без изменения основного кода. В итоге получим
следующий тест

```
# test1.py

def test_boom_cell_builder():
    # note: numeration from 1:1
    state = [
        "   o ",
        " #   ",
        "o #  ",
        "#  # ",
        "#    ",
    ]
    f = FieldFactory.build("\n".join(state), {" ": DiedCell, "#": AliveCell, "o": BoomCell})
    positions = f.get_all_state_pos(BoomCell)
    assert(len(positions) == 2)
    assert([1, 4] in positions)
    assert([3, 1] in positions)
```

* Данная клетка на следующем ходу должна уничтожать все живые клетки вокруг, поэтому добавим проверку на данную часть логики

```
# test1.py

def test_boom_effect():
    state = [
        "   o ",
        " #   ",
        "o #  ",
        "#  # ",
        "#    ",
    ]
    next_state = [
        "     ",
        "     ",
        "  ## ",
        "  #  ",
        " #   ",
    ]
    f = FieldFactory.build("\n".join(state), {" ": DiedCell, "#": AliveCell, "o": BoomCell})
    f.next_state()
    assert(str(f) == "\n".join(next_state))
```

### Итоги

* Который раз убеждаюсь, что создание отдельного класса для отдельного состояния мега сильная и крутая идея
* Так же я решил создать отдельыне тесты, чтобы нагляднее была видна последовательность разработки, позже бы в работе
я объединил это в прошлые тесты (параметризированные) там было бы лучше по логике
* К сожалению, я читаю задания полность перед тем как выполнять, поэтому тут не удалось увидить разницу между просто написал
как обычно и подумал, но для себя я отметил, что это весьма сильная идея - уменьшать вносимые изменения, и тут я сразу потренеровался
это делать и как считаю неплоъо получилось, при этом оставляя тесты зелеными. У себя в работе давно замечал проблему больших вносимых изменений для
тестирования, теперь буду осознанно подходить к решению данной проблемы
* Применять в работе безусловно буду, но только часть: пока я не такой крутой кодер, чтобы безошибочно вносить изменения, а потом это все стирать,
но честно признаться, думая таким образом я действительно уменьшаю кол-во изменения (поэтому буду держать это в голове :), а еще лучше на моем
листочке с заметками, который я невольно читаю каждый день, чтобы это уже было на подкорке).

## Задача 1

### Оригиналы

### После изменения