# Отчет

## Задача 1

### Оригиналы

* https://github.com/skprpi/Hard-Work/blob/main/3/app_after.py
* https://github.com/skprpi/Hard-Work/blob/main/3/test_after.py

### После изменения

* https://github.com/skprpi/Hard-Work/blob/main/6/app1.py
* https://github.com/skprpi/Hard-Work/blob/main/6/test1.py

### Коротко о задаче

Сделать игру жизнь

### Как вносились изменения

* Изначально добавился тест `test_boom_sell_creation` который проверять работу подкласса `BoomCell`. Для минимизации изменений
изначально проверяем, что есть возможности добавлять клетку указанного типа и добовляем класс минимально соответствующий данным требованиям

```
# test1.py

def test_btest_boom_sell_creationoom_sell():
    f = Field(5)
    f.set_random_pos_state(BoomCell(), 1)
    assert f.get_state_count(BoomCell) == 1
```

* Чтобы в будующем проверить специфическую часть логики в начале нужно научить конструировать правильное поле с данным состоянием.
Хорошо, что я сделал достаточно гибким интерфейс и это можно делать на лету без изменения основного кода. В итоге получим
следующий тест

```
# test1.py

def test_boom_cell_builder():
    # note: numeration from 1:1
    state = [
        "   o ",
        " #   ",
        "o #  ",
        "#  # ",
        "#    ",
    ]
    f = FieldFactory.build("\n".join(state), {" ": DiedCell, "#": AliveCell, "o": BoomCell})
    positions = f.get_all_state_pos(BoomCell)
    assert(len(positions) == 2)
    assert([1, 4] in positions)
    assert([3, 1] in positions)
```

* Данная клетка на следующем ходу должна уничтожать все живые клетки вокруг, поэтому добавим проверку на данную часть логики

```
# test1.py

def test_boom_effect():
    state = [
        "   o ",
        " #   ",
        "o #  ",
        "#  # ",
        "#    ",
    ]
    next_state = [
        "     ",
        "     ",
        "  ## ",
        "  #  ",
        " #   ",
    ]
    f = FieldFactory.build("\n".join(state), {" ": DiedCell, "#": AliveCell, "o": BoomCell})
    f.next_state()
    assert(str(f) == "\n".join(next_state))
```

### Итоги

* Который раз убеждаюсь, что создание отдельного класса для отдельного состояния мега сильная и крутая идея
* Так же я решил создать отдельыне тесты, чтобы нагляднее была видна последовательность разработки, позже бы в работе
я объединил это в прошлые тесты (параметризированные) там было бы лучше по логике
* К сожалению, я читаю задания полность перед тем как выполнять, поэтому тут не удалось увидить разницу между просто написал
как обычно и подумал, но для себя я отметил, что это весьма сильная идея - уменьшать вносимые изменения, и тут я сразу потренеровался
это делать и как считаю неплоъо получилось, при этом оставляя тесты зелеными. У себя в работе давно замечал проблему больших вносимых изменений для
тестирования, теперь буду осознанно подходить к решению данной проблемы
* Применять в работе безусловно буду, но только часть: пока я не такой крутой кодер, чтобы безошибочно вносить изменения, а потом это все стирать,
но честно признаться, думая таким образом я действительно уменьшаю кол-во изменения (поэтому буду держать это в голове :), а еще лучше на моем
листочке с заметками, который я невольно читаю каждый день, чтобы это уже было на подкорке).

## Задача 2

### Оригиналы

* их нет, писал код с нуля по предложенной технике

### После изменения

* https://github.com/skprpi/Hard-Work/blob/main/6/app2.py
* https://github.com/skprpi/Hard-Work/blob/main/6/test2.py

### Коротко о задаче

Сделать игру по угадыванию слов c элементами жульничества (будем говорить что игрок ошибся с буквой если есть слова без этой буквы на
месте которое выбрал игрок)

### Как вносились изменения

* Изначально нужно сделать проверку на создание словоря по которому игроки потом будут угадывать слова. Поэтому был создан
следующий тест проверяющий получение слов определенной длинны

```
# test2.py

def test_create_word():
    factory = WordFactory({
        "h1",
        "buy",
        "hello",
        "affix",
        "afoot",
        "after",
        "again",
    })
    factory = factory.get_words_len(5)
    assert len(factory.get_words()) == 5
```

* Теперь добавим тест и функциональность для исключения слов с заданными параметрами пользователя

```
# test2.py

def test_guess_letter():
    factory = WordFactory({
        "h1",
        "buy",
        "hello",
        "affix",
        "afoot",
        "after",
        "again",
    })
    factory = factory.get_words_len(5)
    factory = factory.exclude_words_with_latter('a', 0)
    assert len(factory.get_words()) == 1
    assert "hello" in factory.get_words()
```

* Настало время добавить класс игрка, который решил поиграть в нашу игру и протестировать работу

```
# test2.py

def test_guess_latter():
    p = Player({
        "h1",
        "buy",
        "hello",
        "affix",
        "afoot",
        "after",
        "again",
    }, 5)
    status = p.guess('a', 0)
    assert status == "MISS"

    # here only word hello
    for i, latter in enumerate("hello"):
        status = p.guess(latter, i)
        assert status == "OK"
```

### Итоги

* Выполняя это задание для себя заметил, что если пишешь тест перед кодом, то в голову даже особо и не приходят идеи по
типу "Ща я тут попровлю, а надо бы и еще классик добавить... Всего 40 строк да че на них тест писать и так все ок (а потом запускаешь и час дебажишь :) - про час я конечно условно)". Моей задачей действительно становится просто закрыть тест и порабовать свой глаз зеленым цветом в консольке
* Если правильно написать тест, чему я и учусь, то получается, что ни так много изменений нужно сделать, чтобы его покрыть
* Забываю комитить после прохождения всех тестов - буду следить за этим
