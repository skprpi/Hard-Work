# Отчет

В качестве задачи для отработки задания по TDD я взял игру "жизнь". Прочитав про TDD написал тесты на некотором псевдокоде (т к классов и методов пока нет) получились следующие тесты:

* https://github.com/skprpi/Hard-Work/blob/main/3/test.py

# Что в тестах

* так так я знал что самому придумывать поля будет долго я ориентировался на концепцию, что мы передаем некоему методу `set_random_state` нужно состояние (живая или не живая клетка) и он сам будет ставить в какое-то место выбранное состояние. ПОэтому я создал тесты проверяющие работу данной логики: генерируем несколько полей разных размеров и задаем разное кол-во полей (тесты решил сделать на основе рандома вдохновившись фазерами а если тест валится то можно запомнить `seed` и сделать его воспроизовдимым)
* так же я создал несколько тестов проверяющих переход в следующие состояние

# Код

На основе концепции что у меня есть несколько состояний был построен код (потом я вспомнил про интересную фишку в `LinkedList` с `NilNode` и добавил у себя состояние `EmptyCell` + добавил тестов к нему)
В итоге получилось это:
* https://github.com/skprpi/Hard-Work/blob/main/3/app.py

# Переходим к пункту 2

Прочитав статьи я понял, что моим тестам не хватает:

* строгости (в некоторых тестах)
* крайних случаев
* проверки работы с непредполагаемыми сценариями использования

Именно этих тестов я и добавил

* https://github.com/skprpi/Hard-Work/blob/main/3/test_after.py

# Что-то еще не хватает?

* да, я бы добавил еще больше тестов на проверку конкретных случаев перехода из одного в другое состояние
* проверить не только 1 переход в следующее состояние а проверить серию переходов (для этого случая я бы попробовал сделать `фазирование с мемоизацией` т е фазить какое-то состояние и делать допустим 100 переходов или пока поле не станет пустым [на зацикливание не проверять] и при фазировании нового состояния и перехода проверять не было ли у нас раньше такого состояния - и если было то история того что было должна совпасть с тем что будет сейчас).
Надо будет попробовать данный метод как только будет время и посмотреть его эффективность, но даже сейчас можно сказать что он не подойдет для полей большого размера.
* покрытие кода было-бы неплохо прикрутить

# А как изменился код?

* код практически не изменился ( https://github.com/skprpi/Hard-Work/blob/main/3/app_after.py ) только добавился класс ошибок для тестового случая

# Выводы

* Самое главное что я понял, что код и тесты должны следовать некоторой логике, а не друг другу.
* нужно проверять не только те сценарии которые подразумеваются, но и те, которые могут неожиданно возникнуть - например вызов функции большее колво раз чем планировалось (как в моем случае)
* TDD неплохо помогает (тесты пару раз упали прежде чем увидел зеленую надпись `PASSED`) и при TDD тесты получается как проверка новой функциональноти и дальше как регрессионные
