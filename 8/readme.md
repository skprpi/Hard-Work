# Отчет

### Оригиналы

### Небольшое исследование

Исходя из статьи был понятнен примерный принцип создания миксин, но нужно было разобраться на прикладном уровне
как миксины могут быть полезны конкретно мне и как их применяют, в ходе поиска ответов я наткнулся на данную статью
https://translated.turbopages.org/proxy_u/en-ru.ru.a5bf805c-634a5c07-8d53cea8-74722d776562/https/people.cs.umass.edu/~yannis/practical-fmtd.pdf
и начал ее изучать. Данная статья подходила потому что не противоречила а подтверждала текст приведенный в статье
по патерну виситор.

В статье первый пример расскахывает о создании миксина для подсчета вершин в графе. Концептуально минсин работает
следующим образом: У нас есть шаблонный класс миксина который в качестве шаблонного параметра принимает базовый класс,
который будет расширять, добавляя методы поиска вершины и необходымые поля.

Данный пример очень помог в осознании того, как это быдет выглядеть в моем ЯП (С++). И я понял основную идею миксинов
и сформулировал её так: Миксины - шаблонные классы , которые расширяют поведение базового класса (принятого как шаблонный аргумент).
Данное определение достаточно низкоуровневое, но очень хорошо отражает суть конкретно для меня, что потом поможет расширить мою
модель восприятия миксинов и составить для себя более общеее и правильное определение.

### Постановка задачи

После того, как стало понятно как используются миксины в С++ понятно какие проблемы решают миксины и можно поставить свою
задачу. В качестве тренеровки решил подумать + посмотреть в интеренте какие проблемы обычно решаются миксинами и получил следующий результат:

* `TimeMixin` - миксин позволяющий добавить отслеживание времени для какого-либо объекта. Этот миксин может использоваться для
различных классов метрик которым нужно подсчитывать время
* `InstanseCopyCountMixit` - миксин позволяющий считать кол-во копий который делал объект - может быть полезно для
оценки работы с памятью
* `LoggingMixin` - миксин позволяющий захватить логгер в объект и логировать нужные сообщения

Больше всего мне понравилась идея с захватом логгера, которую я и реализую.

UDP: В процессе реализации стало понятно, что моя идея не совсем подходит т к обычно мы хотим логировать в функции
опередленные события, поэтому логично передать логгер внутрь самого класса. Но тут я подумал и придумал более
применимую на практике схему: Путь у нас есть несколько классов метрик при этом функции достаточно грамоздкие для всех классав,
но при этом методы данных функций возвращают успешно ли выполнился тот или иной метод и теперь наш миксин кажется действительно полезным -
теперь мы можем отслеживать когда функции не смогла выполнится и логировать данное событие - по сути получился некий декоратор

### Использование

Код получился достаточно компактым, поэтому продублирую его сюда:

```
int main() {
    LoggMixin<SomeMetric1, ConsoleLogger> metric1;
    metric1.process(-1000);

    LoggMixin<SomeMetric2, ConsoleLogger> metric2;
    metric2.process(-500);
    return 0;
}
```

В результате в консольке увидим

```
Can't process such parrameter for metrics
Can't process such parrameter for metrics
```

Ровно то, что и ожидалось :)

### Выводы

Я уже достаточно активно начал применять наследование и полиморфизм в том числе и мой любимый `ad-hoc`, но частелько
бывают ситуации когда я пытаюсь вставить функциональность не присущую по смыслу классу - т е когда класс не должен оперировать
некоторыми таймерами или логгерами - доп сущностями которые то появляются то убираются из классов и идея `наследования от шаблона`
в этом плане хорошо повляет на мой стиль кодирования и получится вынести некоторую дополнительную функциональность
в отдельные сущности - миксины и делать их допустим вложенными в друг друга.
