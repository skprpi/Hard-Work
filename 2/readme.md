# Проект:

* https://github.com/skprpi/salesman-problem

# Описание

* строк кода: ~1000
* Язык: C++
* что за проект: решение задачи комивояжера (в проекте я активно использовал ассерты - делать я это стал после одной из прочитанных статей и для этого задания это очень помогло)

# Что сделал

* сам фазинг(libFuzzer): https://github.com/skprpi/salesman-problem/blob/master/tests/fuzz_tests.cpp
* Cmake: https://github.com/skprpi/salesman-problem/blob/master/tests/CMakeLists.txt
* и исправлял ошиби которые фазер находил на раз два :)

# Сложности

* сначала было непонятно как это все работает (статья не сильно решила эту проблему) но когда стал кодить и читать
документацию все стало вставать на места
* сейчас кажется что я написал порядка 100 строк кода (и кажется должно занять не больше часа), но первоначальная настройка и борьба с симейком длилась дольше чем хотелось бы (суммарно потратил порядка 3 часов чтобы примерно понять что к чему)

# Найденные ошибки:

* функция `length` не делает проверку что массив не пуст
* `std::pair<uint32_t, uint32_t> gen_random_idxes(uint32_t max_len)` -> `assert(idx1 <= idx2);`
* `std::pair<uint32_t, uint32_t> gen_random_idxes(uint32_t max_len)` -> `assert(max_len < city.size());`. Как оказалось
корнем ошибки был вызов `auto res = gen_random_idxes(max_len);` в функции `std::vector<uint32_t> gen_range_parallel_idx(uint32_t max_len)` - что в опрочем ожидаемо т к раньше тестировал на больших данных только или на маленьких в своих тестах но эту опцию не тестировал:)
* как оказалось пришлось добавть функцию `get_city_size` чтобы продолжить фазирование (раньше при написании проекта держал это условие в голове хотя от него зависят и другие компоненты)
* `Area::path_length_after_left_insertion(int, unsigned int, unsigned int)`
* а дальяше я понял что их дофига и остановился :)

# Отчёт (самый последний хотя и сгенерирован после очередного падения)

```
stat::number_of_executed_units: 6726
stat::average_exec_per_sec:     0
stat::new_units_added:          1
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              29
```

# Отчет если поменьше итераций поставить 

```
#2      INITED cov: 4 ft: 5 corp: 1/1b exec/s: 0 rss: 27Mb
#1000   DONE   cov: 4 ft: 5 corp: 1/1b lim: 11 exec/s: 0 rss: 27Mb
Done 1000 runs in 0 second(s)
stat::number_of_executed_units: 1000
stat::average_exec_per_sec:     0
stat::new_units_added:          0
stat::slowest_unit_time_sec:    0
stat::peak_rss_mb:              27
```

# Вывод

* фаззер быстро показал мне что написаный мною код никуда не годится и это хорошо, ведь теперь я знаю еще один крутой инструмент для проверки корректности написаных мною программ + понял ещё раз на сколько важны ассерты
* фаззинг сила

# Что еще пофазить?

* будет интересно в дальнейшем с помошью фаззера проверить свой интерпритатор для Lisp :)
