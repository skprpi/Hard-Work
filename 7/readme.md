# Отчет

## Начальное состояние

### Оригиналы

### После изменения

### Постановка задачи

В системе есть 3 класс: `Node`, `OrdinaryNode`, `PatternNode`. Класс `Node` является базовым для остальных.
Данная система классов используется для работы с суффиксым деревом для парсинга. В ходе рефакторинга удалось
оптимизировать постоение дерева за счет добавления новых классов. Новые классы переиспользуют много кода из базового
класса, но переопределяют метод `addChildren` реализую совершенно иную логику. При этом класс `Parser` принимает
набор значений сщщтветствующих классов. Нужно предоставить возможность добавлять ребенка классам `OrdinaryNode`, `PatternNode` без переопределения метода `addChildren`.

Концептуально мы хотим получить следующее поведение:

* Убрать переопределение `addChildren`
* Объект толжен оставать полиморфным т к функция `find` не наружет принципа наследования, а для её поддержки нужен полиморфизм


### Процесс изменения

Для этой задачи будем использовать паттерн `Visitor`. При решении оригинальной задачи (в одном из проектов код в котором
я не могу к сожалению показать) я использовал `std::visit`, по сути это паттерн `Visitor` из коробки, но не очень
синтаксически приятно реализованный. Я решил немного поизучать вопрос какие могут быть аналоги реализации данного
паттерна и нашел интересную статью https://habr.com/ru/post/532412/ и она на много более лаконично реализует данный
паттерн поэтому я решил вникнуть в адский ад мета программирования, но в итоге разобрался и даже получилось красивое
решение.

* Для начала были реализованы дазовые классы, которые были упомянуты в статье
* Удалили ненужный код функции `addChilden` в потомках, вместо этого добавили отдельные хендлеры

```
void AddChildren(OrdinaryNode& node) {
  pattern_nodes.push_back((node));  // Убрали приведение типов
}

// PatternNode
template <class T>
void AddChildren(T& node) {
  node.ordinary_nodes[node->name] = node;  // Убрали приведение типов
}
```
* Изменил обработку самих нод в парсере

```
class Parser {
  void parseOld(std::vector<AbstractObject*> nodes) {
    AbstractObject* node;
    for (auto* node : nodes) {
      node = node->dispatch([](auto& n) { return AddChildren(n); });
    }
  }
};
```

### Выводы

Статический полиморфизм в С++ оказался очень полезным для реализации паттерна `Visitor`, благодяря нему можно
реализовать паттерн красивым способом. В ходе выполнения задания так же познакомился с концепцией CRTP в статье
https://habr.com/ru/post/210894/ (это было нужно для осознания статьи https://habr.com/ru/post/532412/)
