# Отчет

## 1 - анализ задания "Думаем на уровне дизайна"

### Приедисловие

С помощью линейного поиска удалось вычеслить, что это было 3 занятие : https://github.com/skprpi/Hard-Work/tree/main/3 . Рассмотрим тесты которые я написал после рефакторинга еще раз: https://github.com/skprpi/Hard-Work/blob/main/3/test_after.py
Беглый взгляд по тестом дал следующие ошушения:
* Человек который писал тесты явно подумал о приятном интерфейсе для тестирования - имеется ввиду чтобы ему интерфес был удобен а не пользователям (это небольшая самоирония :)
* Человек не очень подумал о людях которые будут читать код. Вот небольшие фрагменты несоответствующие SRP
```
cnt_empty_cells = size + 2 + size + 2 + size + size

f = FieldFactory.build("\n".join(state), {" ": DiedCell, "#": AliveCell})
```

Посмотрел я на свой код до того как смотреть написыный ранее отчет намеренно, чтобы по-новому взглянуть на свой код т к когда пишешь в момент все очевидно и понятно. Общий вывод по тестам такой: нужны комментарии для тесткейсов некоторых чтобы было понятно что именно они тестируют т к тесты скорее интеграционные чем unit, а сценарий далеко не всегда сразу понятен по коду и названиям + подумать как решить проблему SRP для конкретных строк кода

### Теперь смотрим отчет

Посмотрев отчет возник следующий вопрос: давайте взглянем на функцию тестирования например эту:

```
def test_alive_cell():
    for i in range(1, 30):
        f = Field(i)
        cnt = randint(0, i * i)
        f.set_random_pos_state(AliveCell(), cnt)
        assert(f.get_state_count(AliveCell) == cnt)
```

а теперь давайте посмотрим сколько строк кода нужно было написать для этого:

```
class CellState(Enum):
    Alive = 1

class Cell(ABC):
    def __init__(self):
        self.neighors = 0

class EmptyCell(Cell):
    def __init__(self):
        super(Cell).__init__()

class NotEmptyCell(Cell):
    def __init__(self):
        super(Cell).__init__()

class AliveCell(NotEmptyCell):
    def __init__(self):
        super(NotEmptyCell).__init__()

class Field:
    def __init__(self, size: int):
        last_idx = size + 1
        field_len = size + 2
        self.field = [[EmptyCell() if i == last_idx or j == last_idx or i * j == 0 else DiedCell()
            for i in range(field_len)] for j in range(field_len)]

    def __get_random_died_pos(self):
        all_died_cell_pos = self.get_all_state_pos(DiedCell)
        if len(all_died_cell_pos) == 0:
            raise "No palse"
        pos = randint(0, len(all_died_cell_pos) - 1)
        return all_died_cell_pos[pos]

    def set_random_pos_state(self, state: Cell, n: int):
        for _ in range(n):
            x, y = self.__get_random_died_pos()
            self.field[x][y] = state
```

P.S. Код брал на вскидку с минимальным числом методов чтобы примерно понятно был его объем возможно что-то забыл

Не похоже на маленькую итерацию, а этот тест был САМЫМ ПЕРВЫМ. И если вспомнить про TCR то на это бы ушло примерно 2 часа если не больше :) А как же так получилось? Все верно, весь секрет в том что я НЕ СЛЕДОВАЛ ХАРДКОРНОМУ TDD.

### Теперь попробум оценить мой подход в этом задании

* Исходя из объема кода для 1 итерации можно сказать, что был проведен неплохой анализ - т е изначально было спроктирована система классов, потом написаны тесты и только потом код
* Исходя из комментария `проверить не только 1 переход в следующее состояние а проверить серию переходов (для этого случая я бы попробовал сделать фазирование с мемоизацией` я рассматривал не только вариант юнит тестирования и интеграциооного тестирования

### Вывод

* При выполнении этого задлания я не следовал концепции хордкорного TDD (хорошо? да!)
* Двигался достаточно большими итерациями (это больное место до сих пор - работаю над этим)
* Подумал о фазз тестированиия (это плюс)

Общее мнение: учитывая пункты выше можно сказать, что TDD больше похож на методику тестирования, чем проектирования

## 2 - выделяем плюсы и минусы по материалу которые характерны для моего TDD

Тут я немного буду повторяться с прошлым пунктом но еще и постараюсь его дополнить и чуть больше раскрыть

### Плюсы

* Я не делаю слишком маленькие методы/итерации тестирования, что позволяет чуть лучше подумать над конечным дизайном
* Моему стилю больше соответсвут точечное использование приватных чем множество публичных
* Я держу в голове, что тесты не должны следовать коду и код тестам, а все следует дизайну (это не плюс их метериала, но это тоже очень важно)

### Минусы

* Мои итерации скорее большие: если раньше они были `XXXL`, то теперь я смог их уменьшить примерно до `XL`, а хочется уменьшить до `M` или хотя бы для начала до `L` :)
* Код в некоторых местах не такой гибкий как это получается при TDD(Инъекция зависимостей) (это скорее исключение но иногда итерационный подход дает для меня лучший результат)
* Иногда перебор с приватными методами - вместо 2 публичных 1 публичный и 2 приватных, что усложняет логику взаимодействия

Сложновато было расписать по 3 пункта, наиболее хорошими получились первые 2 в + и 1 в -, остальные тяжело выводились и в некоторой степени уже дублируют сказанное

## 3 - мой стиль TDD

На данный момент мне комфортнее воспринимать TDD как технику тестирования нежели как парадигму разработки/lдизайна. Этого подхода и буду придерживаться :)
